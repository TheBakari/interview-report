{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Nikola\\\\Desktop\\\\interview-reports\\\\interview-reports\\\\src\\\\components\\\\ErrorBoundary.jsx\";\n// https://reactjs.org/docs/error-boundaries.html\nimport React from \"react\";\nimport FallbackUI from \"./FallbackUI\";\n/* Use static getDerivedStateFromError() to render a fallback UI after an error\r\nhas been thrown. \r\nUse componentDidCatch() to log error information. */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return {\n      hasError: true\n    };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return /*#__PURE__*/_jsxDEV(FallbackUI, {\n        error: this.state.error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 29,\n        columnNumber: 14\n      }, this);\n    }\n\n    return this.props.children;\n  }\n\n}\n/* \r\nThen you can use it as a regular component:\r\n\r\n<ErrorBoundary> <MyWidget /> </ErrorBoundary> \r\n\r\nError boundaries work like a JavaScript catch {} block, but for components. Only\r\nclass components can be error boundaries. In practice, most of the time you’ll\r\nwant to declare an error boundary component once and use it throughout your\r\napplication.\r\n\r\nNote that error boundaries only catch errors in the components below them in the\r\ntree. An error boundary can’t catch an error within itself. If an error boundary\r\nfails trying to render the error message, the error will propagate to the\r\nclosest error boundary above it. This, too, is similar to how catch {} block\r\nworks in JavaScript.\r\n\r\nNB: errors that were not caught by any error boundary will result in unmounting\r\nof the whole React component tree. !!!\r\n\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\nTODO: PITAJ DA LI SAM U PRAVU ZA OVO:\r\nPošto ja umotavam celu aplikaciju u ErrorBoundary, to rezultira unmountovanjem \r\ncele aplikacije, tj. komponente App.js ????????????????? \r\nTo rešavam u FallbackUI, tako što imam lažni link za refreshovanje home stranice\r\n--------------------------------------------------------------------------------\r\n\r\n*/","map":{"version":3,"sources":["C:/Users/Nikola/Desktop/interview-reports/interview-reports/src/components/ErrorBoundary.jsx"],"names":["React","FallbackUI","ErrorBoundary","Component","constructor","props","state","hasError","error","getDerivedStateFromError","componentDidCatch","errorInfo","console","log","render","children"],"mappings":";AAAA;AAEA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AAEA;AACA;AACA;;;AAEA,eAAe,MAAMC,aAAN,SAA4BF,KAAK,CAACG,SAAlC,CAA4C;AACzDC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa;AAAEC,MAAAA,QAAQ,EAAE,KAAZ;AAAmBC,MAAAA,KAAK,EAAE;AAA1B,KAAb;AACD;;AAE8B,SAAxBC,wBAAwB,CAACD,KAAD,EAAQ;AACrC;AAEA,WAAO;AAAED,MAAAA,QAAQ,EAAE;AAAZ,KAAP;AACD;;AAEDG,EAAAA,iBAAiB,CAACF,KAAD,EAAQG,SAAR,EAAmB;AAClCC,IAAAA,OAAO,CAACC,GAAR,CAAYL,KAAZ,EAAmBG,SAAnB;AACD;;AAEDG,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKR,KAAL,CAAWC,QAAf,EAAyB;AACvB;AACA,0BAAO,QAAC,UAAD;AAAY,QAAA,KAAK,EAAE,KAAKD,KAAL,CAAWE;AAA9B;AAAA;AAAA;AAAA;AAAA,cAAP;AACD;;AAED,WAAO,KAAKH,KAAL,CAAWU,QAAlB;AACD;;AAvBwD;AA0B3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// https://reactjs.org/docs/error-boundaries.html\r\n\r\nimport React from \"react\";\r\nimport FallbackUI from \"./FallbackUI\";\r\n\r\n/* Use static getDerivedStateFromError() to render a fallback UI after an error\r\nhas been thrown. \r\nUse componentDidCatch() to log error information. */\r\n\r\nexport default class ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false, error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    // Update state so the next render will show the fallback UI.\r\n\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.log(error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // You can render any custom fallback UI\r\n      return <FallbackUI error={this.state.error} />;\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n/* \r\nThen you can use it as a regular component:\r\n\r\n<ErrorBoundary> <MyWidget /> </ErrorBoundary> \r\n\r\nError boundaries work like a JavaScript catch {} block, but for components. Only\r\nclass components can be error boundaries. In practice, most of the time you’ll\r\nwant to declare an error boundary component once and use it throughout your\r\napplication.\r\n\r\nNote that error boundaries only catch errors in the components below them in the\r\ntree. An error boundary can’t catch an error within itself. If an error boundary\r\nfails trying to render the error message, the error will propagate to the\r\nclosest error boundary above it. This, too, is similar to how catch {} block\r\nworks in JavaScript.\r\n\r\nNB: errors that were not caught by any error boundary will result in unmounting\r\nof the whole React component tree. !!!\r\n\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\nTODO: PITAJ DA LI SAM U PRAVU ZA OVO:\r\nPošto ja umotavam celu aplikaciju u ErrorBoundary, to rezultira unmountovanjem \r\ncele aplikacije, tj. komponente App.js ????????????????? \r\nTo rešavam u FallbackUI, tako što imam lažni link za refreshovanje home stranice\r\n--------------------------------------------------------------------------------\r\n\r\n*/\r\n"]},"metadata":{},"sourceType":"module"}